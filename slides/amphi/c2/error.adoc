== Gestion des erreurs

Les erreurs de validation n'entrent pas dans le code de la fonction.

La gestion est externe et générique.

== Current schema

[mermaid]
----
%%{init: { 'logLevel': 'debug', 'theme': 'dark'} }%%
flowchart TD
    Client --> |deserialization| MyController
    MyController <--> MyService
    MyController --> |serialization| Client
----

[NOTE.speaker]
--
Vision simple d'une application
--

== DispatcherServlet

[mermaid]
----
%%{init: { 'logLevel': 'debug', 'theme': 'dark'} }%%
flowchart TD
    Client --> |deserialization| DispatcherServlet
    DispatcherServlet <--> MyController
    MyController <--> MyService
    DispatcherServlet --> |serialization| Client
----

[NOTE.speaker]
--
En rentrant un peu dans spring,
il y a une couche pour passer de la servlet au controlleur
--

== DispatcherServlet

[mermaid]
----
%%{init: { 'logLevel': 'debug', 'theme': 'dark'} }%%
flowchart TD
    Client --> |deserialization| DispatcherServlet
    DispatcherServlet <--> MyController
    MyController <--> MyService
    DispatcherServlet --> |serialization| Client
    DispatcherServlet --> |translateError| ControllerAdvice
----

[NOTE.speaker]
--
Ce dispatcher va gérer les erreurs en s'appuyant sur un ControllerAdvice
--

== DispatcherServlet - PSEUDO-code

[source, kotlin]
----
fun dispatch(request: HttpServletRequest) {
    try {
        val parameters = deserialize(request)
        val handler = getHandler(request)
        val response = handler.handle(parameters)
        return serialize(response)
    } catch (e: Exception) {
        val response = errorHandler.handle(e)
        return serialize(response)
    }
}
----

[NOTE.speaker]
--
Autrement dit en pseudo code il fait ca.
C'est une vision très très simplifié.
--

[transition=fade-out]
== ControllerAdvice

[source, kotlin]
----
@ControllerAdvice
class HttpErrorHandler {




}
----

[NOTE.speaker]
--
Un ControllerAdvice est un Bean particulier.
Comme RestController ou @Configuration,
il a son propre cycle de vie.
--

[transition=slide-in none-out]
== ControllerAdvice

[source, kotlin]
----
@ControllerAdvice
class HttpErrorHandler {


    fun handleMethodArgumentNotValid(e: MethodArgumentNotValidException) =
        ResponseEntity.badRequest().body("You're arg is invalid")
}
----

[NOTE.speaker]
--
On peut lui donner des methodes pour lui expliquer comment traiter une exception
--

[transition=none-in slide-out]
== ControllerAdvice

[source, kotlin]
----
@ControllerAdvice
class HttpErrorHandler {

    @ExceptionHandler(MethodArgumentNotValidException::class)
    fun handleMethodArgumentNotValid(e: MethodArgumentNotValidException) =
        ResponseEntity.badRequest().body("You're arg is invalid")
}
----

[NOTE.speaker]
--
Comme le RestController, 
il faut une annotation pour que Spring puisse faire le lien
--

[transition=none-in slide-out]
== ControllerAdvice

[source, kotlin]
----
@ControllerAdvice
class HttpErrorHandler {

    @ExceptionHandler(MethodArgumentNotValidException::class)
    fun handleMethodArgumentNotValid(e: MethodArgumentNotValidException) =
        ResponseEntity.badRequest().body("You're arg is invalid")

    @ExceptionHandler(Exception::class)
    fun fallback(e: Exception) =
        ResponseEntity.internalServerError().body("Unhandled error")
}
----

[NOTE.speaker]
--
La gestion des exceptions est en entonnoir, 
On peut traiter les erreurs spécialisées et avoir des couches de traitement de plus en plus génériques
--

[transition=fade-out]
== ControllerAdvice - Spring

[source, kotlin]
----
@ControllerAdvice
class HttpErrorHandler : ResponseEntityExceptionHandler() {

  override fun handleMethodArgumentNotValid(e: MethodArgumentNotValidException,
                                            headers: HttpHeaders,
                                            status: HttpStatusCode,
                                            request: WebRequest)
                                            : ResponseEntity<Any>? {
      return ResponseEntity.badRequest().body("You're arg is invalid")
  }
}
----

[NOTE.speaker]
--
Il est aussi possible d'étendre la gestion par défaut de Spring

Pour ça il faut étendre ResponseEntityExceptionHandler et surcharger les handlers
--

== Tests

[source,kotlin]
----
@AutoConfigureMockMvc
@SpringBootTest
class MovieControllerTest {

    @Autowired
    lateinit var mockMvc: MockMvc
----

[NOTE.speaker]
--
Spring fournit une outils pour faire des tests d'appels API

Le but est de simuler des appels externes, 
sans avoir à faire toute la Configuration d'un client HTTP

L'activation se fait par l'ajout de @AutoConfigureMockMvc,
et on peut injecter MockMvc
--

[transition=fade-in, fade-out]
== MockMvc

[source,kotlin]
----
fun post() {
    mockMvc.post("/api/demo")


 

 



}
----

[transition=fade-in, fade-out]
== MockMvc

[source,kotlin]
----
fun post() {
    mockMvc.post("/api/demo") {
        contentType = MediaType.APPLICATION_JSON
        content = ObjectMapper()
            .writeValueAsString(DemoEntity(name = "name"))
    }




}
----

[transition=fade-in, fade-out]
== MockMvc

[source,kotlin]
----
fun post() {
    mockMvc.post("/api/demo") {
        contentType = MediaType.APPLICATION_JSON
        content = ObjectMapper()
            .writeValueAsString(DemoEntity(name = "name"))
    }
    .andExpect {
        status { isOk() }

    }
}
----


[.columns]
== Layers

[.column]
--
@SpringBootTest

[mermaid]
----
%%{init: { 'logLevel': 'debug', 'theme': 'dark'} }%%
flowchart TD
    Controller --> Service
    Service --> Repository
----
--

[fragment, step=1]
[.column]
--
@WebMvcTest

[mermaid]
----
%%{init: { 'logLevel': 'debug', 'theme': 'dark'} }%%
flowchart TD
    Controller --> MockService
----
--

[NOTE.speaker]
--
Spring propose des tests de couche (layer).

Ces tests ne lancent qu'une partie de l'application.

Pour la partie web il faut remplacer @SpringBootTest par @WebMvcTest.
--

== WebMvcTest

[source,kotlin]
----
@WebMvcTest
class DemoControllerTest {

    @MockkBean
    private lateinit var demoRepository: Repository
    @Autowired
    private lateinit var mockMvc: MockMvc

    @Test
    fun get() {
        every { demoRepository.save(any()) } returns Unit
        mockMvc.get("/api/demo")
                .andExpect { status { isOk() } }
    }
}
----

[NOTE.speaker]
--
On peut remplacer les deux annotations par WebMvcTest

Mais il faut fournir des mocks des beans
--

== WebMvcTest

[source,kotlin]
----
@WebMvcTest(DemoController::class)
class DemoControllerTest {

    @MockkBean
    private lateinit var demoRepository: Repository
    @Autowired
    private lateinit var mockMvc: MockMvc

    @Test
    fun get() {
        every { demoRepository.save(any()) } returns Unit
        mockMvc.get("/api/demo")
                .andExpect { status { isOk() } }
    }
}
----

[NOTE.speaker]
--
Pour limiter encore plus,
on peut limiter à un controlleur
--
